<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Earth Rotation — Inertial vs Rotating Frame</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0f172a; overflow: hidden; font-family: system-ui, -apple-system, sans-serif; }

    #info {
      position: absolute; top: 16px; left: 16px; z-index: 10;
      color: #e2e8f0; max-width: 360px;
    }
    #info h2 { font-size: 15px; font-weight: 600; margin-bottom: 4px; }
    #info p { font-size: 12px; color: #94a3b8; line-height: 1.4; }

    #legend {
      position: absolute; bottom: 20px; left: 20px; z-index: 10;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 8px; padding: 12px 16px;
      color: #cbd5e1; font-size: 12px; line-height: 2;
    }
    .legend-row { display: flex; align-items: center; gap: 10px; }
    .swatch { width: 24px; height: 3px; border-radius: 2px; flex-shrink: 0; }
    .swatch-dot {
      width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0;
      margin: 0 9px;
    }

    #controls {
      position: absolute; bottom: 20px; right: 20px; z-index: 10;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 8px; padding: 14px 18px;
      color: #cbd5e1; font-size: 12px;
    }
    .control-row {
      display: flex; flex-direction: column; gap: 4px;
      margin-bottom: 10px;
    }
    .control-row:last-child { margin-bottom: 0; }
    .control-row label {
      display: flex; justify-content: space-between; align-items: center;
      font-weight: 500;
    }
    .control-row label span { color: #e2e8f0; font-variant-numeric: tabular-nums; }
    input[type="range"] {
      width: 200px; height: 4px;
      accent-color: #3b82f6;
      cursor: pointer;
    }

    .mode-toggle {
      display: flex; gap: 0; margin-bottom: 12px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-radius: 6px; overflow: hidden;
    }
    .mode-toggle button {
      flex: 1; padding: 6px 10px;
      background: transparent; border: none;
      color: #94a3b8; font-size: 11px; font-weight: 500;
      cursor: pointer; transition: background 0.15s, color 0.15s;
    }
    .mode-toggle button.active {
      background: rgba(59, 130, 246, 0.25);
      color: #e2e8f0;
    }
    .mode-toggle button:not(:last-child) {
      border-right: 1px solid rgba(148, 163, 184, 0.3);
    }

    .point-label {
      color: #f1f5f9; font-size: 13px; font-weight: 600;
      text-shadow: 0 1px 6px rgba(0,0,0,0.9);
      pointer-events: none; white-space: nowrap;
    }
    .comp-label {
      font-size: 11px; font-weight: 500;
      text-shadow: 0 1px 4px rgba(0,0,0,0.95);
      pointer-events: none; white-space: nowrap;
    }
  </style>
</head>
<body>
  <div id="info">
    <h2>Earth Rotation &mdash; Inertial vs Rotating Frame</h2>
    <p>Drag to orbit &middot; Scroll to zoom</p>
    <p style="margin-top:6px">
      Switch between two viewpoints: the <strong>inertial frame</strong> (camera
      fixed relative to the stars &mdash; Earth spins) and the <strong>rotating
      frame</strong> (camera fixed relative to Earth &mdash; stars spin).
    </p>
    <p style="margin-top:4px">
      The physics are identical in both frames; only the viewpoint changes.
    </p>
  </div>

  <div id="legend">
    <div class="legend-row">
      <span class="swatch" style="background:#3b82f6"></span>
      &Omega; &mdash; rotation axis
    </div>
    <div class="legend-row">
      <span class="swatch" style="background:#60a5fa"></span>
      Meridian lines (show spin)
    </div>
    <div class="legend-row">
      <span class="swatch-dot" style="background:#e2e8f0"></span>
      Star field (inertial reference)
    </div>
  </div>

  <div id="controls">
    <div class="mode-toggle">
      <button id="btn-inertial" class="active">Inertial frame</button>
      <button id="btn-rotating">Rotating frame</button>
    </div>
    <div class="control-row">
      <label>Spin speed <span id="speed-value">50%</span></label>
      <input type="range" id="speed-slider" min="0" max="100" value="50" step="1">
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

    // ── State ──
    const DEG = Math.PI / 180;
    const MAX_ROTATION_SPEED = Math.PI * 0.13; // rad/s → 1 rev per ~15 s
    let speedFraction = 0.5;
    let mode = 'inertial'; // 'inertial' or 'rotating'
    let earthAngle = 0;    // accumulated rotation angle (rad)

    // ── Scene ──
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 200);
    camera.position.set(3.5, 2.0, 3.5);

    const gl = new THREE.WebGLRenderer({ antialias: true });
    gl.setSize(innerWidth, innerHeight);
    gl.setPixelRatio(devicePixelRatio);
    gl.setClearColor(0x0f172a);
    document.body.appendChild(gl.domElement);

    const cssRenderer = new CSS2DRenderer();
    cssRenderer.setSize(innerWidth, innerHeight);
    cssRenderer.domElement.style.position = 'absolute';
    cssRenderer.domElement.style.top = '0';
    cssRenderer.domElement.style.pointerEvents = 'none';
    document.body.appendChild(cssRenderer.domElement);

    const orbit = new OrbitControls(camera, gl.domElement);
    orbit.enableDamping = true;
    orbit.dampingFactor = 0.08;
    orbit.enablePan = false; // always look at center
    orbit.target.set(0, 0, 0);
    orbit.update();

    // ── Helpers ──
    function makeLabel(text, cls, color) {
      const el = document.createElement('div');
      el.className = cls;
      if (color) el.style.color = color;
      el.textContent = text;
      return new CSS2DObject(el);
    }

    // ── Star field (large sphere with random star points) ──
    const starGroup = new THREE.Group();
    scene.add(starGroup);

    const STAR_COUNT = 2000;
    const STAR_RADIUS = 80;
    const starPositions = new Float32Array(STAR_COUNT * 3);
    const starColors = new Float32Array(STAR_COUNT * 3);

    for (let i = 0; i < STAR_COUNT; i++) {
      // Uniform distribution on sphere surface
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = STAR_RADIUS;
      starPositions[i * 3]     = r * Math.sin(phi) * Math.cos(theta);
      starPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
      starPositions[i * 3 + 2] = r * Math.cos(phi);

      // Slight color variation: white to warm to cool
      const tint = Math.random();
      if (tint < 0.7) {
        // White-ish
        const b = 0.8 + Math.random() * 0.2;
        starColors[i * 3] = b;
        starColors[i * 3 + 1] = b;
        starColors[i * 3 + 2] = b;
      } else if (tint < 0.85) {
        // Warm (yellowish)
        starColors[i * 3] = 0.9 + Math.random() * 0.1;
        starColors[i * 3 + 1] = 0.8 + Math.random() * 0.15;
        starColors[i * 3 + 2] = 0.5 + Math.random() * 0.2;
      } else {
        // Cool (bluish)
        starColors[i * 3] = 0.6 + Math.random() * 0.2;
        starColors[i * 3 + 1] = 0.7 + Math.random() * 0.2;
        starColors[i * 3 + 2] = 0.9 + Math.random() * 0.1;
      }
    }

    const starGeom = new THREE.BufferGeometry();
    starGeom.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    starGeom.setAttribute('color', new THREE.BufferAttribute(starColors, 3));

    const starMaterial = new THREE.PointsMaterial({
      size: 0.6,
      vertexColors: true,
      sizeAttenuation: true,
      transparent: true,
      opacity: 0.9,
    });
    starGroup.add(new THREE.Points(starGeom, starMaterial));

    // ── Earth group (sphere + markers) ──
    const earthGroup = new THREE.Group();
    scene.add(earthGroup);

    // Opaque sphere (kept as reference for label occlusion raycasting)
    const earthMesh = new THREE.Mesh(
      new THREE.SphereGeometry(1, 64, 32),
      new THREE.MeshBasicMaterial({ color: 0x1a2744 })
    );
    earthGroup.add(earthMesh);
    const occludedLabels = []; // CSS2DObjects to hide when behind the sphere
    earthGroup.add(new THREE.Mesh(
      new THREE.SphereGeometry(1.002, 24, 12),
      new THREE.MeshBasicMaterial({
        color: 0x60a5fa, wireframe: true, transparent: true, opacity: 0.08
      })
    ));

    // Static reference circles (equator + prime meridian) — on Earth
    function addRefCircle(parent, pointFn, color, opacity) {
      const pts = [];
      for (let i = 0; i <= 128; i++) pts.push(pointFn((i / 128) * Math.PI * 2));
      parent.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints(pts),
        new THREE.LineBasicMaterial({ color, transparent: true, opacity })
      ));
    }
    addRefCircle(earthGroup, a => new THREE.Vector3(Math.cos(a), 0, Math.sin(a)), 0x94a3b8, 0.15);
    addRefCircle(earthGroup, a => new THREE.Vector3(Math.cos(a), Math.sin(a), 0), 0x94a3b8, 0.15);

    // Meridian lines (the rotating markers)
    for (let m = 0; m < 3; m++) {
      const lon = (m / 3) * Math.PI; // 0°, 60°, 120° → 6 visible meridians
      const pts = [];
      for (let i = 0; i <= 64; i++) {
        const a = (i / 64) * Math.PI * 2;
        pts.push(new THREE.Vector3(
          Math.cos(a) * Math.cos(lon),
          Math.sin(a),
          Math.cos(a) * Math.sin(lon)
        ));
      }
      earthGroup.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints(pts),
        new THREE.LineBasicMaterial({ color: 0x60a5fa, transparent: true, opacity: 0.3 })
      ));
    }

    // Land-like markers: small colored dots at recognizable positions
    const markers = [
      { lat: 90, lon: 0, color: 0xff4444, label: 'N' },   // North pole
      { lat: -90, lon: 0, color: 0xff4444, label: 'S' },   // South pole
      { lat: 0, lon: 0, color: 0x22c55e },                  // On equator/prime meridian
      { lat: 0, lon: 90, color: 0x22c55e },                 // Equator 90E
      { lat: 45, lon: 30, color: 0xfbbf24 },                // Mid-latitude marker
      { lat: 45, lon: 150, color: 0xfbbf24 },
      { lat: -30, lon: -60, color: 0xfbbf24 },
      { lat: -30, lon: 120, color: 0xfbbf24 },
    ];

    for (const m of markers) {
      const phi = m.lat * DEG;
      const lam = m.lon * DEG;
      const r = 1.005;
      const pos = new THREE.Vector3(
        r * Math.cos(phi) * Math.cos(lam),
        r * Math.sin(phi),
        r * Math.cos(phi) * Math.sin(lam)
      );
      const dotGeom = new THREE.SphereGeometry(0.025, 8, 8);
      const dotMesh = new THREE.Mesh(dotGeom, new THREE.MeshBasicMaterial({ color: m.color }));
      dotMesh.position.copy(pos);
      earthGroup.add(dotMesh);

      if (m.label) {
        const lbl = makeLabel(m.label, 'point-label', '#' + m.color.toString(16).padStart(6, '0'));
        lbl.position.copy(pos.clone().multiplyScalar(1.08));
        earthGroup.add(lbl);
        occludedLabels.push(lbl);
      }
    }

    // ── Rotation axis (always visible, aligned with scene Y) ──
    const axLine = new THREE.Line(
      new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, -1.5, 0), new THREE.Vector3(0, 1.5, 0)
      ]),
      new THREE.LineDashedMaterial({
        color: 0x3b82f6, dashSize: 0.06, gapSize: 0.04, transparent: true, opacity: 0.35
      })
    );
    axLine.computeLineDistances();
    scene.add(axLine);

    scene.add(new THREE.ArrowHelper(
      new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1.3, 0),
      0.2, 0x3b82f6, 0.08, 0.035
    ));
    const omegaLbl = makeLabel('Ω', 'comp-label', '#60a5fa');
    omegaLbl.position.set(0, 1.58, 0);
    scene.add(omegaLbl);
    occludedLabels.push(omegaLbl);

    // ── Controls ──
    const speedSlider = document.getElementById('speed-slider');
    const speedValue = document.getElementById('speed-value');
    const btnInertial = document.getElementById('btn-inertial');
    const btnRotating = document.getElementById('btn-rotating');

    speedSlider.addEventListener('input', () => {
      speedFraction = +speedSlider.value / 100;
      speedValue.textContent = Math.round(speedFraction * 100) + '%';
    });

    function switchMode(newMode) {
      if (newMode === mode) return;
      // When switching, the scene objects jump by earthAngle around Y.
      // Rotate the camera by the same amount so the view stays identical.
      const delta = (newMode === 'rotating') ? -earthAngle : earthAngle;
      const cos = Math.cos(delta), sin = Math.sin(delta);
      const p = camera.position;
      const x = p.x, z = p.z;
      p.x = x * cos + z * sin;
      p.z = -x * sin + z * cos;
      mode = newMode;
      btnInertial.classList.toggle('active', mode === 'inertial');
      btnRotating.classList.toggle('active', mode === 'rotating');
      orbit.update();
    }

    btnInertial.addEventListener('click', () => switchMode('inertial'));
    btnRotating.addEventListener('click', () => switchMode('rotating'));

    // ── Resize ──
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      gl.setSize(innerWidth, innerHeight);
      cssRenderer.setSize(innerWidth, innerHeight);
    });

    // ── Render loop ──
    let lastTime = performance.now();

    (function loop() {
      requestAnimationFrame(loop);
      const now = performance.now();
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      // Accumulate rotation
      earthAngle += MAX_ROTATION_SPEED * speedFraction * dt;

      if (mode === 'inertial') {
        // Camera is fixed in star frame → Earth rotates, stars stay still
        earthGroup.rotation.y = earthAngle;
        starGroup.rotation.y = 0;
      } else {
        // Camera is fixed in Earth frame → stars rotate backwards, Earth stays still
        earthGroup.rotation.y = 0;
        starGroup.rotation.y = -earthAngle;
      }

      // Occlude labels behind the Earth sphere
      const raycaster = new THREE.Raycaster();
      const camPos = camera.position;
      for (const lbl of occludedLabels) {
        // Get label world position
        const lblWorld = new THREE.Vector3();
        lbl.getWorldPosition(lblWorld);
        const dir = lblWorld.clone().sub(camPos).normalize();
        raycaster.set(camPos, dir);
        const hits = raycaster.intersectObject(earthMesh, false);
        const dist = camPos.distanceTo(lblWorld);
        // Hide if the sphere is hit closer than the label
        const blocked = hits.length > 0 && hits[0].distance < dist;
        lbl.visible = !blocked;
      }

      orbit.update();
      gl.render(scene, camera);
      cssRenderer.render(scene, camera);
    })();
  </script>
</body>
</html>
